"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSchemaFromDefinitions = exports.definitionsContainReference = exports.mapPropertiesToTitles = exports.isStateType = exports.isArrayType = exports.relativeImportPath = exports.dereferenceSchema = exports.parseShorthandValidation = exports.convertShorthandStringToJsonSchema = exports.convertShorthandObjectToJsonSchema = exports.isRootNamespace = exports.removeNamespace = exports.NAMESPACE = exports.compileSchema = exports.COMPILE_OPTIONS = void 0;
const json_schema_to_typescript_1 = require("json-schema-to-typescript");
const _ = __importStar(require("lodash"));
const path_1 = __importDefault(require("path"));
const json_schema_ref_parser_1 = __importDefault(require("@apidevtools/json-schema-ref-parser"));
const lib_1 = require("@proophboard/cody-utils/lib");
const cody_types_1 = require("@proophboard/cody-types");
exports.COMPILE_OPTIONS = {
    style: { tabWidth: 4 },
    declareExternallyReferenced: false,
    bannerComment: `/* tslint:disable */
/**
 * This file was automatically generated by proophboard/Cody.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source element on your prooph board,
 * and let Cody generate the file again.
 */`
};
const compileSchema = async (schema, schemaName, sourcePath, defs, additionalContent = '') => {
    schema = _.cloneDeep(schema);
    defs = _.cloneDeep(defs);
    if (schema.hasOwnProperty('type') && (schema.type === 'array')) {
        const itemSchema = await (0, exports.compileSchema)(schema.items, schemaName + 'Item', sourcePath, defs, additionalContent);
        return `${itemSchema}        
export type ${schemaName} = ${schemaName}Item[];        
        `;
    }
    schema.definitions = defs.definitions;
    if (schema.hasOwnProperty('$ref')) {
        const ref = schema['$ref'];
        const refName = ref.replace('#/definitions/', '');
        if (!defs.sourceMap.hasOwnProperty('/' + refName)) {
            throw new Error(`Cannot find reference ${ref} in sourceMap of schema-definitions.json`);
        }
        if (!(0, exports.definitionsContainReference)(refName, defs)) {
            throw new Error(`Cannot find reference ${ref} in schema-definitions.json`);
        }
        const refSource = defs.sourceMap['/' + refName];
        const importPath = (0, exports.relativeImportPath)(sourcePath, refSource);
        return `${exports.COMPILE_OPTIONS.bannerComment}

import {${(0, exports.removeNamespace)(refName)}} from "${importPath}";

export type ${schemaName} = ${(0, exports.removeNamespace)(refName)}; 

${additionalContent}
`.replace(/[\n]+$/, '\n');
    }
    // Clone a second time, because schema is modified for compilation purpose only
    const compilableSchema = _.cloneDeep(schema);
    // When a title is present an interface is generated using the title as name
    // Since we disabled declareExternallyReferenced, interfaces are not generated but props are still typed as if the interfaces would exist
    // This is not what we want but this behaviour cannot be deactivated, see: https://github.com/bcherny/json-schema-to-typescript/issues/311
    // Hence, we need to silently remove all titles from the schema in our local schema copy
    removeAllTitles(compilableSchema);
    const refs = filterRefs(compilableSchema);
    // All external refs should result in a typed property. jsonschema-to-typescript uses jsonschema-ref-parser internally to dereference the entire schema.
    // We can force the desired behavior by removing all titles from internal types (see above), but ensure that all ref schemas have a title.
    normalizeRefsTitles(compilableSchema, compilableSchema.definitions, refs);
    const compiledContent = await (0, json_schema_to_typescript_1.compile)(compilableSchema, schemaName, { ...exports.COMPILE_OPTIONS, bannerComment: exports.COMPILE_OPTIONS.bannerComment });
    return (addImportsForRefs(compiledContent, sourcePath, schema, defs, refs) + `\n${additionalContent}\n`).replace(/[\n]+$/, '\n');
};
exports.compileSchema = compileSchema;
const deleteTitle = (schema) => {
    if (schema.title) {
        delete schema.title;
    }
    if (schema.id) {
        delete schema.id;
    }
};
const removeAllTitles = (schema) => {
    var _a, _b, _c;
    if (schema.hasOwnProperty('type') && (schema.type === 'array')) {
        deleteTitle(schema);
        removeAllTitles(schema.items || {});
        return;
    }
    if (schema.hasOwnProperty('$ref')) {
        deleteTitle(schema);
        return;
    }
    if ('oneOf' in schema) {
        deleteTitle(schema);
        (_a = schema.oneOf) === null || _a === void 0 ? void 0 : _a.forEach(oneOf => removeAllTitles(oneOf));
        return;
    }
    if ('anyOf' in schema) {
        deleteTitle(schema);
        (_b = schema.anyOf) === null || _b === void 0 ? void 0 : _b.forEach(anyOf => removeAllTitles(anyOf));
        return;
    }
    if ('allOf' in schema) {
        deleteTitle(schema);
        (_c = schema.allOf) === null || _c === void 0 ? void 0 : _c.forEach(allOf => removeAllTitles(allOf));
        return;
    }
    if (schema.hasOwnProperty('type') && (schema.type === 'object')) {
        deleteTitle(schema);
        Object.values(schema.properties || {}).forEach(propVal => removeAllTitles(propVal));
        return;
    }
    deleteTitle(schema);
    return;
};
const jsonPointerToLodashPath = (pointer) => {
    if (pointer.charAt(0) === '/') {
        pointer = pointer.slice(1);
    }
    return pointer.replace(/\//g, '.');
};
const lodashPathToType = (lodashPath, refs) => {
    const pathParts = lodashPath.split('.');
    const type = pathParts[pathParts.length - 1];
    return refs.conflicts.includes(type) ? lodashPath.replace(/\./g, '') : type;
};
const normalizeRefTitle = (schema, defs, refs) => {
    if ('$ref' in schema) {
        const ref = schema['$ref'];
        const defKey = ref.replace('#/definitions', '');
        const refPath = jsonPointerToLodashPath(defKey);
        const refSchema = _.get(defs, refPath);
        if (refSchema) {
            refSchema.title = lodashPathToType(refPath, refs);
        }
    }
    return schema;
};
const normalizeRefsTitles = (schema, defs, refs) => {
    var _a, _b, _c;
    if ('$ref' in schema) {
        normalizeRefTitle(schema, defs, refs);
        return;
    }
    if ('items' in schema) {
        normalizeRefsTitles(schema.items, defs, refs);
    }
    if ('properties' in schema) {
        for (const prop in schema.properties) {
            if (schema.properties.hasOwnProperty(prop)) {
                normalizeRefsTitles(schema.properties[prop], defs, refs);
            }
        }
    }
    if ('oneOf' in schema) {
        (_a = schema.oneOf) === null || _a === void 0 ? void 0 : _a.forEach(subSchema => {
            normalizeRefsTitles(subSchema, defs, refs);
        });
    }
    if ('anyOf' in schema) {
        (_b = schema.anyOf) === null || _b === void 0 ? void 0 : _b.forEach(subSchema => {
            normalizeRefsTitles(subSchema, defs, refs);
        });
    }
    if ('allOf' in schema) {
        (_c = schema.allOf) === null || _c === void 0 ? void 0 : _c.forEach(subSchema => {
            normalizeRefsTitles(subSchema, defs, refs);
        });
    }
};
const isRef = (ref, schema) => {
    // This check is important in case title matches a potential value object, but schema does not reference the VO
    if (schema.title && schema.title.replace(" ", "") === ref) {
        return schema.hasOwnProperty('$ref');
    }
    if (schema.type === "object" && schema.properties) {
        for (const prop of Object.keys(schema.properties)) {
            if (!isRef(ref, schema.properties[prop])) {
                return false;
            }
        }
    }
    if (schema.type === "array" && schema.items) {
        if (!isRef(ref, schema.items)) {
            return false;
        }
    }
    return true;
};
const addRefToList = (ref, references) => {
    const refName = (0, exports.removeNamespace)(ref);
    if (references.list.includes(ref)) {
        return;
    }
    if (references.types.includes(refName)) {
        references.conflicts.push(refName);
    }
    else {
        references.types.push(refName);
    }
    references.list.push(ref);
};
const filterRefs = (schema, references) => {
    var _a, _b, _c;
    if (!references) {
        references = {
            list: [],
            types: [],
            conflicts: [],
        };
    }
    if (schema.hasOwnProperty('$ref')) {
        addRefToList(schema['$ref'], references);
        return references;
    }
    if ('items' in schema) {
        references = filterRefs(schema.items, references);
    }
    if ('properties' in schema) {
        for (const prop in schema.properties) {
            if (schema.properties.hasOwnProperty(prop)) {
                references = filterRefs(schema.properties[prop], references);
            }
        }
    }
    if ('oneOf' in schema) {
        (_a = schema.oneOf) === null || _a === void 0 ? void 0 : _a.forEach(subSchema => {
            references = filterRefs(subSchema, references);
        });
    }
    if ('anyOf' in schema) {
        (_b = schema.anyOf) === null || _b === void 0 ? void 0 : _b.forEach(subSchema => {
            references = filterRefs(subSchema, references);
        });
    }
    if ('allOf' in schema) {
        (_c = schema.allOf) === null || _c === void 0 ? void 0 : _c.forEach(subSchema => {
            references = filterRefs(subSchema, references);
        });
    }
    return references;
};
const addImportsForRefs = (content, sourcePath, schema, defs, refs) => {
    const parts = content.split('\nexport ');
    let imports = '';
    const internalTypes = [];
    for (const part of parts) {
        const matchRes = part.match(/^([\s]+)?(interface|type) ([^\s]+) /);
        if (!matchRes) {
            continue;
        }
        internalTypes.push(matchRes[3]);
    }
    refs.list.forEach(ref => {
        const refName = ref.replace('#/definitions/', '');
        if (!defs.sourceMap.hasOwnProperty('/' + refName)) {
            throw new Error(`Cannot find reference ${ref} in sourceMap of schema-definitions.json`);
        }
        if (!(0, exports.definitionsContainReference)(refName, defs)) {
            throw new Error(`Cannot find reference ${ref} in schema-definitions.json`);
        }
        const refSource = defs.sourceMap['/' + refName];
        const importPath = (0, exports.relativeImportPath)(sourcePath, refSource);
        const refType = lodashPathToType(jsonPointerToLodashPath(refName), refs);
        if ((0, exports.removeNamespace)(ref) === refType) {
            imports = imports + `import {${refType}} from "${importPath}";\n`;
        }
        else {
            imports = imports + `import {${(0, exports.removeNamespace)(ref)} as ${refType}} from "${importPath}";\n`;
        }
    });
    if (parts.length) {
        parts[0] = parts[0] + `\n${imports}`;
        return parts.join('\nexport ');
    }
    return content;
};
exports.NAMESPACE = "namespace";
const removeNamespace = (ref) => {
    const refParts = ref.split("/");
    return refParts[refParts.length - 1];
};
exports.removeNamespace = removeNamespace;
const isRootNamespace = (ref) => {
    return ref.length > 0 && ref.charAt(0) === "/";
};
exports.isRootNamespace = isRootNamespace;
const convertShorthandObjectToJsonSchema = (shorthand, namespace) => {
    const schema = {
        type: "object",
        properties: {},
        required: [],
        additionalProperties: false,
    };
    if (typeof shorthand !== 'object') {
        return {
            cody: `I was not able to convert shorthand object: "${JSON.stringify(shorthand)}" to JSONSchema`,
            type: cody_types_1.CodyResponseType.Error
        };
    }
    if (!namespace) {
        namespace = "/";
    }
    if (namespace.charAt(namespace.length - 1) !== "/") {
        namespace += "/";
    }
    for (const property in shorthand) {
        if (!shorthand.hasOwnProperty(property)) {
            continue;
        }
        if (property === '') {
            return {
                cody: `Shorthand object ${JSON.stringify(shorthand)} contains an empty property string. Can't deal with that.`,
                details: "Please remove it!",
                type: cody_types_1.CodyResponseType.Error
            };
        }
        let schemaProperty = property;
        if (property.slice(-1) === '?') {
            schemaProperty = property.slice(0, property.length - 1);
        }
        else if (property === "$ref") {
            if (Object.keys(shorthand).length > 1) {
                return {
                    cody: `Shorthand ${JSON.stringify(shorthand)} contains a top level ref property "$ref", but it is not the only property!`,
                    details: 'A top level reference cannot have other properties then "$ref".',
                    type: cody_types_1.CodyResponseType.Error
                };
            }
            const reference = shorthand[schemaProperty].replace('#/definitions', '');
            if ((0, exports.isRootNamespace)(reference)) {
                return {
                    "$ref": `#/definitions${reference}`
                };
            }
            return {
                "$ref": `#/definitions${namespace}${reference}`
            };
        }
        else if (property === '$items') {
            if (typeof shorthand[schemaProperty] !== 'string') {
                return {
                    cody: `Detected a top level shorthand array using an "$items" prop, but the value of the property is not a string.`,
                    details: "It is of type " + typeof shorthand[schemaProperty],
                    type: cody_types_1.CodyResponseType.Error
                };
            }
            if (Object.keys(shorthand).length > 1) {
                // Allow title as the only alternative property
                if (!Object.keys(shorthand).includes('$title')) {
                    return {
                        cody: `Shorthand ${JSON.stringify(shorthand)} contains a top level array property "$items", but it is not the only property!`,
                        details: 'A top level array cannot have other properties then "$items".',
                        type: cody_types_1.CodyResponseType.Error
                    };
                }
            }
            let itemsShorthandSchema = shorthand[schemaProperty];
            if (itemsShorthandSchema.slice(-2) !== '[]') {
                itemsShorthandSchema = itemsShorthandSchema + '[]';
            }
            const arraySchema = (0, exports.convertShorthandStringToJsonSchema)(itemsShorthandSchema, namespace);
            if (!(0, lib_1.isCodyError)(arraySchema) && Object.keys(shorthand).includes('$title')) {
                arraySchema.title = shorthand['$title'];
            }
            return arraySchema;
        }
        else if (schemaProperty === '$title') {
            schema.title = shorthand[property];
            delete shorthand[property];
            continue;
        }
        else {
            if (schema.required && Array.isArray(schema.required)) {
                schema.required.push(property);
            }
        }
        if (typeof shorthand[property] === "object") {
            const propertySchemaObj = (0, exports.convertShorthandObjectToJsonSchema)(shorthand[property], namespace);
            if ((0, lib_1.isCodyError)(propertySchemaObj)) {
                return propertySchemaObj;
            }
            schema.properties[schemaProperty] = propertySchemaObj;
        }
        else if (typeof shorthand[property] === "string") {
            const propertySchema = (0, exports.convertShorthandStringToJsonSchema)(shorthand[property], namespace);
            if ((0, lib_1.isCodyError)(propertySchema)) {
                return propertySchema;
            }
            schema.properties[schemaProperty] = propertySchema;
        }
        else {
            return {
                cody: `I tried to parse JSONSchema for property: "${property}", but it is neither a string nor an object.`,
                details: "Can you check that please?!",
                type: cody_types_1.CodyResponseType.Error
            };
        }
    }
    return schema;
};
exports.convertShorthandObjectToJsonSchema = convertShorthandObjectToJsonSchema;
const convertShorthandStringToJsonSchema = (shorthand, namespace) => {
    if (shorthand === '') {
        return { type: "string" };
    }
    if (namespace === "") {
        namespace = "/";
    }
    if (namespace.charAt(namespace.length - 1) !== "/") {
        namespace += "/";
    }
    const parts = shorthand.split('|');
    if (parts[0].match(/^enum:/)) {
        const enumVals = parts[0].replace('enum:', '');
        return {
            enum: enumVals.split(',').map(val => val.trim()),
        };
    }
    if (parts[0].slice(-2) === '[]') {
        const itemsParts = [parts[0].replace('[]', '')];
        itemsParts.push(...parts.slice(1));
        const itemsSchema = (0, exports.convertShorthandStringToJsonSchema)(itemsParts.join('|'), namespace);
        if ((0, lib_1.isCodyError)(itemsSchema)) {
            return itemsSchema;
        }
        return {
            type: "array",
            items: itemsSchema
        };
    }
    switch (parts[0]) {
        case 'string':
        case 'integer':
        case 'number':
        case 'boolean':
            let type = parts[0];
            if (parts[1] && parts[1] === 'null') {
                type = [type, 'null'];
                parts.splice(1, 1);
            }
            const schema = {
                type,
            };
            if (parts.length > 1) {
                for (const part of parts.slice(1)) {
                    const validation = (0, exports.parseShorthandValidation)(part);
                    if ((0, lib_1.isCodyError)(validation)) {
                        return validation;
                    }
                    schema[validation[0]] = validation[1];
                }
            }
            return schema;
        default:
            let ref = parts[0];
            const schemaProps = {};
            if (parts.length > 1) {
                const valParts = parts.filter((item, i) => i > 0);
                for (const valPart of valParts) {
                    const validation = (0, exports.parseShorthandValidation)(valPart);
                    if ((0, lib_1.isCodyError)(validation)) {
                        return validation;
                    }
                    const [prop, val] = validation;
                    schemaProps[prop] = val;
                }
            }
            if (!(0, exports.isRootNamespace)(ref) && schemaProps.hasOwnProperty(exports.NAMESPACE)) {
                ref = schemaProps[exports.NAMESPACE] + '/' + ref;
            }
            if (schemaProps.hasOwnProperty(exports.NAMESPACE)) {
                delete schemaProps[exports.NAMESPACE];
            }
            if ((0, exports.isRootNamespace)(ref)) {
                return {
                    "$ref": `#/definitions${ref}`,
                    ...schemaProps
                };
            }
            return {
                "$ref": `#/definitions${namespace}${ref}`,
                ...schemaProps
            };
    }
};
exports.convertShorthandStringToJsonSchema = convertShorthandStringToJsonSchema;
const parseShorthandValidation = (validation) => {
    const parts = validation.split(':');
    if (parts.length !== 2) {
        return {
            cody: `Can't parse shorthand validation: "${validation}". Expected format "validationKey:value". Please check again!`,
            type: cody_types_1.CodyResponseType.Error
        };
    }
    const [validationKey, value] = parts;
    if (value === 'true') {
        return [validationKey, true];
    }
    if (value === 'false') {
        return [validationKey, false];
    }
    if (parseInt(value, 10).toString() === value) {
        return [validationKey, parseInt(value, 10)];
    }
    if (parseFloat(value).toString() === value) {
        return [validationKey, parseFloat(value)];
    }
    if (validationKey === "ns") {
        return [exports.NAMESPACE, value];
    }
    if (validationKey[0] === "$") {
        return [validationKey.slice(1), { $data: '1/' + value.split(".").join("/") }];
    }
    return [validationKey, value];
};
exports.parseShorthandValidation = parseShorthandValidation;
const dereferenceSchema = async (schema, defs) => {
    if (schema['$ref']) {
        const ref = schema['$ref'];
        const subSchemaName = ref.replace('#/definitions/', '');
        if ((0, exports.definitionsContainReference)(subSchemaName, defs)) {
            const tmpSubSchema = (0, exports.getSchemaFromDefinitions)(subSchemaName, defs);
            if (tmpSubSchema) {
                const subSchema = await (0, exports.dereferenceSchema)(tmpSubSchema, defs);
                const orgCopy = { ...schema };
                delete orgCopy['$ref'];
                return { ...subSchema, ...orgCopy };
            }
        }
    }
    const schemaCopy = { ...schema, definitions: defs.definitions };
    const unreferencedSchema = await json_schema_ref_parser_1.default.dereference(schemaCopy);
    delete unreferencedSchema.definitions;
    return unreferencedSchema;
};
exports.dereferenceSchema = dereferenceSchema;
const relativeImportPath = (sourcePath, refSource) => {
    let importPath = path_1.default.relative(sourcePath.replace(/\/[^\/]+\.ts$/, ''), refSource).replace(/\.ts$/, '');
    const importPathParts = importPath.split('/');
    if (importPathParts.length > 0 && importPathParts[0] !== ".." && importPathParts[0] !== ".") {
        importPath = `./${importPath}`;
    }
    return importPath;
};
exports.relativeImportPath = relativeImportPath;
const isArrayType = (def, defs) => {
    if (!(0, exports.definitionsContainReference)(def, defs)) {
        return false;
    }
    const schema = (0, exports.getSchemaFromDefinitions)(def, defs);
    if (!schema) {
        return false;
    }
    if (!schema.hasOwnProperty('type')) {
        return false;
    }
    return schema.type === 'array';
};
exports.isArrayType = isArrayType;
const isStateType = async (def, defs) => {
    if (!(0, exports.definitionsContainReference)(def, defs)) {
        return false;
    }
    const tmpSchema = (0, exports.getSchemaFromDefinitions)(def, defs);
    if (!tmpSchema) {
        return false;
    }
    const schema = await (0, exports.dereferenceSchema)(tmpSchema, defs);
    if (!schema.hasOwnProperty('type')) {
        return false;
    }
    return schema.type === 'object';
};
exports.isStateType = isStateType;
const mapPropertiesToTitles = (schema, property) => {
    const schemaCopy = JSON.parse(JSON.stringify(schema));
    if (property && !schema.title) {
        schemaCopy.title = (0, lib_1.camelCaseToTitle)((0, lib_1.snakeCaseToCamelCase)(property));
    }
    if (schema.type && schema.type === 'object' && schema.properties) {
        Object.keys(schema.properties).forEach(key => {
            const propSchema = schema.properties[key];
            schemaCopy.properties[key] = (0, exports.mapPropertiesToTitles)(propSchema, key);
        });
    }
    if (schema.type && schema.type === 'array' && schema.items) {
        schemaCopy.items = (0, exports.mapPropertiesToTitles)(schema.items);
    }
    return schemaCopy;
};
exports.mapPropertiesToTitles = mapPropertiesToTitles;
const definitionsContainReference = (ref, defs) => {
    if (ref.length === 0) {
        return false;
    }
    if (ref.charAt(0) === '/') {
        ref = ref.slice(1);
    }
    const refPath = ref.split("/");
    let defDefinitions = defs.definitions;
    let pathFound = true;
    refPath.forEach(pathPart => {
        if (!defDefinitions.hasOwnProperty(pathPart)) {
            pathFound = false;
            return false;
        }
        defDefinitions = defDefinitions[pathPart];
    });
    return pathFound;
};
exports.definitionsContainReference = definitionsContainReference;
const getSchemaFromDefinitions = (def, defs) => {
    if (def.length === 0) {
        return null;
    }
    if (def.charAt(0) === '/') {
        def = def.slice(1);
    }
    const refPath = def.split("/");
    let defDefinitions = defs.definitions;
    let pathFound = true;
    refPath.forEach(pathPart => {
        if (!defDefinitions.hasOwnProperty(pathPart)) {
            pathFound = false;
            return false;
        }
        defDefinitions = defDefinitions[pathPart];
    });
    if (pathFound) {
        return JSON.parse(JSON.stringify(defDefinitions));
    }
    return null;
};
exports.getSchemaFromDefinitions = getSchemaFromDefinitions;
