import {compile, JSONSchema} from "json-schema-to-typescript";
import * as _ from "lodash";
import path from "path";
import $RefParser from "@apidevtools/json-schema-ref-parser";
import {camelCaseToTitle, isCodyError, snakeCaseToCamelCase} from "@proophboard/cody-utils/lib";
import {CodyResponse, CodyResponseType} from "@proophboard/cody-types";

export const COMPILE_OPTIONS = {
    style: {tabWidth: 4},
    declareExternallyReferenced: false,
    bannerComment: `/* tslint:disable */
/**
 * This file was automatically generated by proophboard/Cody.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source element on your prooph board,
 * and let Cody generate the file again.
 */`
}

export interface SchemaDefinitions {
    sourceMap: {
        [defName: string]: string,
    },
    definitions: {
        [defName: string]: JSONSchema
    }
}

interface References {
    list: string[];
    types: string[];
    conflicts: string[];
}

export const compileSchema =  async (schema: JSONSchema, schemaName: string, sourcePath: string, defs: SchemaDefinitions, additionalContent: string = ''): Promise<string> => {
    schema = _.cloneDeep(schema);
    defs = _.cloneDeep(defs);


    if(schema.hasOwnProperty('type') && (schema.type === 'array')) {
        const itemSchema = await compileSchema(schema.items as JSONSchema, schemaName + 'Item', sourcePath, defs, additionalContent);

        return `${itemSchema}        
export type ${schemaName} = ${schemaName}Item[];        
        `;
    }

    schema.definitions = defs.definitions;

    if(schema.hasOwnProperty('$ref')) {
        const ref = schema['$ref'] as string;
        const refName = ref.replace('#/definitions/', '');

        if(!defs.sourceMap.hasOwnProperty('/' + refName)) {
            throw new Error(`Cannot find reference ${ref} in sourceMap of schema-definitions.json`);
        }

        if(!definitionsContainReference(refName, defs)) {
            throw new Error(`Cannot find reference ${ref} in schema-definitions.json`);
        }

        const refSource = defs.sourceMap['/'+refName];
        const importPath = relativeImportPath(sourcePath, refSource);

        return `${COMPILE_OPTIONS.bannerComment}

import {${removeNamespace(refName)}} from "${importPath}";

export type ${schemaName} = ${removeNamespace(refName)}; 

${additionalContent}
`.replace(/[\n]+$/, '\n');
    }

    // Clone a second time, because schema is modified for compilation purpose only
    const compilableSchema = _.cloneDeep(schema);

    // When a title is present an interface is generated using the title as name
    // Since we disabled declareExternallyReferenced, interfaces are not generated but props are still typed as if the interfaces would exist
    // This is not what we want but this behaviour cannot be deactivated, see: https://github.com/bcherny/json-schema-to-typescript/issues/311
    // Hence, we need to silently remove all titles from the schema in our local schema copy
    removeAllTitles(compilableSchema);

    const refs = filterRefs(compilableSchema);

    // All external refs should result in a typed property. jsonschema-to-typescript uses jsonschema-ref-parser internally to dereference the entire schema.
    // We can force the desired behavior by removing all titles from internal types (see above), but ensure that all ref schemas have a title.
    normalizeRefsTitles(compilableSchema, compilableSchema.definitions!, refs);

    const compiledContent = await compile(compilableSchema, schemaName, {...COMPILE_OPTIONS, bannerComment: COMPILE_OPTIONS.bannerComment});

    return (addImportsForRefs(compiledContent, sourcePath, schema, defs, refs) + `\n${additionalContent}\n`).replace(/[\n]+$/, '\n');
}

const deleteTitle = (schema: JSONSchema): void => {
    if(schema.title) {
        delete schema.title;
    }

    if(schema.id) {
        delete schema.id;
    }
}

const removeAllTitles = (schema: JSONSchema): void => {
    if(schema.hasOwnProperty('type') && (schema.type === 'array')) {
      deleteTitle(schema);
      removeAllTitles(schema.items || {});
      return;
    }

    if(schema.hasOwnProperty('$ref')) {
        deleteTitle(schema);
        return;
    }

    if('oneOf' in schema) {
        deleteTitle(schema);
        schema.oneOf?.forEach(oneOf => removeAllTitles(oneOf));
        return;
    }

    if('anyOf' in schema) {
        deleteTitle(schema);
        schema.anyOf?.forEach(anyOf => removeAllTitles(anyOf));
        return;
    }

    if('allOf' in schema) {
        deleteTitle(schema);
        schema.allOf?.forEach(allOf => removeAllTitles(allOf));
        return;
    }

    if(schema.hasOwnProperty('type') && (schema.type === 'object')) {
        deleteTitle(schema);
        Object.values(schema.properties || {}).forEach(propVal => removeAllTitles(propVal))
        return;
    }

    deleteTitle(schema);
    return;
}

const jsonPointerToLodashPath = (pointer: string): string => {
    if(pointer.charAt(0) === '/') {
        pointer = pointer.slice(1);
    }

    return pointer.replace(/\//g, '.');
}

const lodashPathToType = (lodashPath: string, refs: References): string => {
    const pathParts = lodashPath.split('.');
    const type = pathParts[pathParts.length - 1];

    return refs.conflicts.includes(type)? lodashPath.replace(/\./g, '') : type;
}

const normalizeRefTitle = (schema: JSONSchema, defs: SchemaDefinitions['definitions'], refs: References): JSONSchema => {
    if('$ref' in schema) {
        const ref = schema['$ref'] as string;
        const defKey = ref.replace('#/definitions', '');
        const refPath = jsonPointerToLodashPath(defKey);
        const refSchema = _.get(defs, refPath);

        if(refSchema) {
            refSchema.title = lodashPathToType(refPath, refs);
        }
    }
    return schema;
}

const normalizeRefsTitles = (schema: JSONSchema, defs: SchemaDefinitions['definitions'], refs: References): void => {
    if('$ref' in schema) {
        normalizeRefTitle(schema, defs, refs);
        return;
    }

    if('items' in schema) {
        normalizeRefsTitles(schema.items as JSONSchema, defs, refs);
    }

    if('properties' in schema) {
        for (const prop in schema.properties) {
            if(schema.properties.hasOwnProperty(prop)) {
                normalizeRefsTitles(schema.properties[prop] as JSONSchema, defs, refs);
            }
        }
    }

    if('oneOf' in schema) {
        schema.oneOf?.forEach(subSchema => {
            normalizeRefsTitles(subSchema, defs, refs);
        })
    }

    if('anyOf' in schema) {
        schema.anyOf?.forEach(subSchema => {
            normalizeRefsTitles(subSchema, defs, refs);
        })
    }

    if('allOf' in schema) {
        schema.allOf?.forEach(subSchema => {
            normalizeRefsTitles(subSchema, defs, refs);
        })
    }
}

const isRef = (ref: string, schema: JSONSchema): boolean => {
    // This check is important in case title matches a potential value object, but schema does not reference the VO
    if(schema.title && schema.title.replace(" ", "") === ref) {
        return schema.hasOwnProperty('$ref');
    }

    if(schema.type === "object" && schema.properties) {
        for(const prop of Object.keys(schema.properties)) {
            if(!isRef(ref, schema.properties[prop])) {
                return false
            }
        }
    }

    if(schema.type === "array" && schema.items) {
        if(!isRef(ref, schema.items)) {
            return false;
        }
    }

    return true;
}

const addRefToList = (ref: string, references: References): void => {
    const refName = removeNamespace(ref);

    if(references.list.includes(ref)) {
        return;
    }

    if(references.types.includes(refName)) {
        references.conflicts.push(refName)
    } else {
        references.types.push(refName);
    }

    references.list.push(ref);
}

const filterRefs = (schema: JSONSchema, references?: References): References => {

    if(!references) {
        references = {
            list: [],
            types: [],
            conflicts: [],
        }
    }

    if(schema.hasOwnProperty('$ref')) {
        addRefToList(schema['$ref'] as string, references);
        return references;
    }

    if('items' in schema) {
        references = filterRefs(schema.items!, references);
    }



    if('properties' in schema) {
        for (const prop in schema.properties) {
            if(schema.properties.hasOwnProperty(prop)) {
                references = filterRefs(schema.properties[prop] as JSONSchema, references);
            }
        }
    }

    if('oneOf' in schema) {
        schema.oneOf?.forEach(subSchema => {
            references = filterRefs(subSchema, references);
        })
    }

    if('anyOf' in schema) {
        schema.anyOf?.forEach(subSchema => {
            references = filterRefs(subSchema, references);
        })
    }

    if('allOf' in schema) {
        schema.allOf?.forEach(subSchema => {
            references = filterRefs(subSchema, references);
        })
    }

    return references;
}

const addImportsForRefs = (content: string, sourcePath: string, schema: JSONSchema, defs: SchemaDefinitions, refs: References): string => {
    const parts = content.split('\nexport ');
    let imports = '';
    const internalTypes: string[] = [];

    for(const part of parts) {
        const matchRes = part.match(/^([\s]+)?(interface|type) ([^\s]+) /);

        if (!matchRes) {
            continue;
        }

        internalTypes.push(matchRes[3]);
    }

    refs.list.forEach(ref => {
        const refName = ref.replace('#/definitions/', '');

        if(!defs.sourceMap.hasOwnProperty('/' + refName)) {
            throw new Error(`Cannot find reference ${ref} in sourceMap of schema-definitions.json`);
        }

        if(!definitionsContainReference(refName, defs)) {
            throw new Error(`Cannot find reference ${ref} in schema-definitions.json`);
        }

        const refSource = defs.sourceMap['/'+refName];
        const importPath = relativeImportPath(sourcePath, refSource);
        const refType = lodashPathToType(jsonPointerToLodashPath(refName), refs);

        if(removeNamespace(ref) === refType) {
            imports = imports + `import {${refType}} from "${importPath}";\n`;
        } else {
            imports = imports + `import {${removeNamespace(ref)} as ${refType}} from "${importPath}";\n`;
        }
    });

    if(parts.length) {
        parts[0] = parts[0] + `\n${imports}`;

        return parts.join('\nexport ');
    }

    return content;
}

export const NAMESPACE = "namespace";

export const removeNamespace = (ref: string): string => {
    const refParts = ref.split("/");

    return refParts[refParts.length - 1];
}

export const isRootNamespace = (ref: string): boolean => {
    return ref.length > 0 && ref.charAt(0) === "/";
}

export interface ShorthandObject {[property: string]: ShorthandObject | string}

export const convertShorthandObjectToJsonSchema = (shorthand: ShorthandObject, namespace?: string): JSONSchema | CodyResponse => {
    const schema: JSONSchema = {
        type: "object",
        properties: {},
        required: [],
        additionalProperties: false,
    };

    if(typeof shorthand !== 'object') {
        return {
            cody: `I was not able to convert shorthand object: "${JSON.stringify(shorthand)}" to JSONSchema`,
            type: CodyResponseType.Error
        }
    }

    if(!namespace) {
        namespace = "/";
    }

    if(namespace.charAt(namespace.length - 1) !== "/") {
        namespace += "/";
    }

    for (const property in shorthand) {
        if(!shorthand.hasOwnProperty(property)) { continue; }

        if(property === '') {
            return {
                cody: `Shorthand object ${JSON.stringify(shorthand)} contains an empty property string. Can't deal with that.`,
                details: "Please remove it!",
                type: CodyResponseType.Error
            }
        }

        let schemaProperty = property;

        if(property.slice(-1) === '?') {
            schemaProperty = property.slice(0, property.length - 1);
        } else if (property === "$ref") {
            if(Object.keys(shorthand).length > 1) {
                return {
                    cody: `Shorthand ${JSON.stringify(shorthand)} contains a top level ref property "$ref", but it is not the only property!`,
                    details: 'A top level reference cannot have other properties then "$ref".',
                    type: CodyResponseType.Error
                }
            }

            const reference = (shorthand[schemaProperty] as string).replace('#/definitions', '');

            if(isRootNamespace(reference)) {
                return {
                    "$ref": `#/definitions${reference}`
                };
            }

            return {
                "$ref": `#/definitions${namespace}${reference}`
            };
        } else if (property === '$items') {
            if(typeof shorthand[schemaProperty] !== 'string') {
                return {
                    cody: `Detected a top level shorthand array using an "$items" prop, but the value of the property is not a string.`,
                    details: "It is of type " + typeof shorthand[schemaProperty],
                    type: CodyResponseType.Error
                }
            }

            if(Object.keys(shorthand).length > 1) {
                // Allow title as the only alternative property
                if(!Object.keys(shorthand).includes('$title')) {
                    return {
                        cody: `Shorthand ${JSON.stringify(shorthand)} contains a top level array property "$items", but it is not the only property!`,
                        details: 'A top level array cannot have other properties then "$items".',
                        type: CodyResponseType.Error
                    }
                }
            }

            let itemsShorthandSchema = shorthand[schemaProperty] as string;

            if(itemsShorthandSchema.slice(-2) !== '[]') {
                itemsShorthandSchema = itemsShorthandSchema + '[]';
            }

            const arraySchema = convertShorthandStringToJsonSchema(itemsShorthandSchema, namespace);

            if(!isCodyError(arraySchema) && Object.keys(shorthand).includes('$title')) {
                arraySchema.title = shorthand['$title'] as string;
            }

            return arraySchema;
        } else if (schemaProperty === '$title') {
            schema.title = shorthand[property] as string;
            delete shorthand[property];
            continue;
        } else {
            if(schema.required && Array.isArray(schema.required)) {
                schema.required.push(property);
            }
        }

        if(typeof shorthand[property] === "object") {
            const propertySchemaObj = convertShorthandObjectToJsonSchema(shorthand[property] as ShorthandObject, namespace);

            if(isCodyError(propertySchemaObj)) {
                return propertySchemaObj;
            }

            schema.properties![schemaProperty] = propertySchemaObj;
        } else if(typeof shorthand[property] === "string") {
            const propertySchema = convertShorthandStringToJsonSchema(shorthand[property] as string, namespace);

            if(isCodyError(propertySchema)) {
                return propertySchema;
            }

            schema.properties![schemaProperty] = propertySchema;
        } else {
            return {
                cody: `I tried to parse JSONSchema for property: "${ property }", but it is neither a string nor an object.`,
                details: "Can you check that please?!",
                type: CodyResponseType.Error
            }
        }
    }

    return schema;
}

export const convertShorthandStringToJsonSchema = (shorthand: string, namespace: string): JSONSchema | CodyResponse => {
    if(shorthand === '') {
        return {type: "string"}
    }

    if(namespace === "") {
        namespace = "/";
    }

    if(namespace.charAt(namespace.length - 1) !== "/") {
        namespace += "/";
    }

    const parts = shorthand.split('|');

    if(parts[0].match(/^enum:/)) {
        const enumVals = parts[0].replace('enum:', '');
        return {
            enum: enumVals.split(',').map(val => val.trim()),
        }
    }

    if(parts[0].slice(-2) === '[]') {
        const itemsParts = [parts[0].replace('[]', '')];
        itemsParts.push(...parts.slice(1));

        const itemsSchema = convertShorthandStringToJsonSchema(itemsParts.join('|'), namespace);

        if(isCodyError(itemsSchema)) {
            return itemsSchema;
        }

        return {
            type: "array",
            items: itemsSchema
        }
    }

    switch (parts[0]) {
        case 'string':
        case 'integer':
        case 'number':
        case 'boolean':
            let type: string | string[] = parts[0];

            if(parts[1] && parts[1] === 'null') {
                type = [type as string, 'null'];
                parts.splice(1,1);
            }

            const schema: {[schemaProp: string]: string | boolean | number | string[] | {$data: string}} = {
                type,
            };

            if(parts.length > 1) {
                for (const part of parts.slice(1)) {
                    const validation = parseShorthandValidation(part);

                    if(isCodyError(validation)) {
                        return validation;
                    }

                    schema[validation[0]] = validation[1];
                }
            }

            return schema;
        default:
            let ref = parts[0];
            const schemaProps: {[name: string]: any} = {};

            if(parts.length > 1) {
                const valParts = parts.filter((item, i) => i > 0);

                for (const valPart of valParts) {
                    const validation = parseShorthandValidation(valPart);

                    if (isCodyError(validation)) {
                        return validation;
                    }

                    const [prop, val] = validation;

                    schemaProps[prop] = val;
                }
            }

            if(!isRootNamespace(ref) && schemaProps.hasOwnProperty(NAMESPACE)) {
                ref = schemaProps[NAMESPACE] + '/' + ref;
            }

            if (schemaProps.hasOwnProperty(NAMESPACE)) {
                delete schemaProps[NAMESPACE];
            }

            if(isRootNamespace(ref)) {
                return {
                    "$ref": `#/definitions${ref}`,
                    ...schemaProps
                };
            }

            return {
                "$ref": `#/definitions${namespace}${ref}`,
                ...schemaProps
            }
    }
}

export const parseShorthandValidation = (validation: string): [string, string | number | boolean | {$data: string}] | CodyResponse => {
    const parts = validation.split(':');

    if(parts.length !== 2) {
        return {
            cody: `Can't parse shorthand validation: "${validation}". Expected format "validationKey:value". Please check again!`,
            type: CodyResponseType.Error
        }
    }

    const [validationKey, value] = parts;

    if(value === 'true') {
        return [validationKey, true];
    }

    if(value === 'false') {
        return [validationKey, false];
    }

    if(parseInt(value, 10).toString() === value) {
        return [validationKey, parseInt(value, 10)];
    }

    if(parseFloat(value).toString() === value) {
        return [validationKey, parseFloat(value)];
    }

    if(validationKey === "ns") {
        return [NAMESPACE, value];
    }

    if(validationKey[0] === "$") {
        return [validationKey.slice(1), {$data: '1/' + value.split(".").join("/")}]
    }

    return [validationKey, value];
}

export const dereferenceSchema = async (schema: JSONSchema, defs: SchemaDefinitions): Promise<JSONSchema> => {
    if(schema['$ref']) {
        const ref: string = schema['$ref'];
        const subSchemaName = ref.replace('#/definitions/', '');
        if(definitionsContainReference(subSchemaName, defs)) {
            const tmpSubSchema = getSchemaFromDefinitions(subSchemaName, defs);

            if(tmpSubSchema) {
                const subSchema = await dereferenceSchema(tmpSubSchema, defs);
                const orgCopy = {...schema};
                delete orgCopy['$ref'];

                return {...subSchema, ...orgCopy};
            }
        }
    }

    const schemaCopy = {...schema, definitions: defs.definitions};

    const unreferencedSchema = await $RefParser.dereference(schemaCopy);

    delete unreferencedSchema.definitions;

    return unreferencedSchema as JSONSchema;
}

export const relativeImportPath = (sourcePath: string, refSource: string): string => {
    let importPath = path.relative(sourcePath.replace(/\/[^\/]+\.ts$/, ''), refSource).replace(/\.ts$/, '');

    const importPathParts = importPath.split('/');

    if(importPathParts.length > 0 && importPathParts[0] !== ".." && importPathParts[0] !== ".") {
        importPath = `./${importPath}`;
    }

    return importPath;
}

export const isArrayType = (def: string, defs: SchemaDefinitions): boolean => {
    if(!definitionsContainReference(def, defs)) {
        return false;
    }

    const schema = getSchemaFromDefinitions(def, defs);

    if(!schema) {
        return false;
    }

    if(!schema.hasOwnProperty('type')) {
        return false;
    }

    return schema.type === 'array';
}

export const isStateType = async (def: string, defs: SchemaDefinitions): Promise<boolean> => {
    if(!definitionsContainReference(def, defs)) {
        return false;
    }

    const tmpSchema = getSchemaFromDefinitions(def, defs);

    if(!tmpSchema) {
        return false;
    }

    const schema = await dereferenceSchema(tmpSchema, defs);

    if(!schema.hasOwnProperty('type')) {
        return false;
    }

    return schema.type === 'object';
}

export const mapPropertiesToTitles = (schema: JSONSchema, property?: string): JSONSchema => {
    const schemaCopy = JSON.parse(JSON.stringify(schema));

    if(property && !schema.title) {
        schemaCopy.title = camelCaseToTitle(snakeCaseToCamelCase(property));
    }

    if(schema.type && schema.type === 'object' && schema.properties) {
        Object.keys(schema.properties).forEach(key => {
            const propSchema = schema.properties![key];
            schemaCopy.properties[key] = mapPropertiesToTitles(propSchema, key);
        })
    }

    if(schema.type && schema.type === 'array' && schema.items) {
        schemaCopy.items = mapPropertiesToTitles(schema.items);
    }

    return schemaCopy;
}

export const definitionsContainReference = (ref: string, defs: SchemaDefinitions): boolean => {
    if(ref.length === 0) {
        return false;
    }

    if(ref.charAt(0) === '/') {
        ref = ref.slice(1);
    }

    const refPath = ref.split("/");
    let defDefinitions = defs.definitions;
    let pathFound = true;

    refPath.forEach(pathPart => {
        if(!defDefinitions.hasOwnProperty(pathPart)) {
            pathFound = false;
            return false;
        }

        defDefinitions = defDefinitions[pathPart];
    })

    return pathFound;
}

export const getSchemaFromDefinitions = (def: string, defs: SchemaDefinitions): JSONSchema | null => {
    if(def.length === 0) {
        return null;
    }

    if(def.charAt(0) === '/') {
        def = def.slice(1);
    }

    const refPath = def.split("/");
    let defDefinitions = defs.definitions;
    let pathFound = true;

    refPath.forEach(pathPart => {
        if(!defDefinitions.hasOwnProperty(pathPart)) {
            pathFound = false;
            return false;
        }

        defDefinitions = defDefinitions[pathPart];
    })

    if(pathFound) {
        return JSON.parse(JSON.stringify(defDefinitions));
    }

    return null;
}
